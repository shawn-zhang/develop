2016.1.7
HIFI:
    SRC问题、DAC问题和信号放大:
SRC: resample / Sample Rate Convertor
模拟信号放大，因为DAC或者Codec出来的信号比较弱，没法直接推动耳机出声，需要放大，放大过程中也很容易失真，这是智能手机做Hi-Fi的第三个重点
DB:
    Bel(贝尔) --> deciBel (dB (分贝尔)) 是用来表示电信功率讯号的增益和衰减的单位, 1个贝尔的增益是以功率在放大后与放大之前的比值.
    我们来看看分贝究竟怎样复杂和简单。
    声音的响度是指在单位时间内通过指定大小的面积内的能量的总和：
    响度 = 能量 / （时间*面积）
    我们知道能量和时间的比就是功率：
    响度 = 功率 / 面积
    功率的单位是瓦特，面积我们用平方米，那么响度的单位就是：瓦 / 米^
    现在我们假设你知道普通人能听见的最小的声音响度是0.000000000001 瓦 / 米^，而让人开始感到痛苦的声音响度是1 瓦 / 米^，那么在这两个数字之间，我们会得到一大堆值，比如0.000792710162 瓦 / 米^，还有0.000006288415 瓦 / 米^等等，试试迅速比较这两个数字，算出它们的差！你能想象我们的峰值表用这种单位做表示吗？
    科学家们写下了这样的公式：
    log (0.000792710162) = -3.1
    log (0.000006288415) = -5.2
    这个音量差是2.1，后来进行了演化：
    10 * log (0.000792710162) = -31
    10 * log (0.000006288415) = -52
    答案从2.1变成了21，这个"21"就是今天的分贝。
    还有一个小问题，如果我们得到的测量数据不全是以声音响度为单位的，那该怎么办？如果两个数据的单位不一样，我们得到的公式不就毁了吗？想想看，我们通常用什么方法来让不同单位的数值进行计算，并且得到同样单位的结果的？其实我们只需要找一个固定的常数带入这个公式就可以解决这问题了，我们把这个常数叫做“参照数”。用什么来作参照数呢？刚才我们好像提到过普通人能听见的最小的声音响度是0.000000000001瓦 / 米^，用字母"N"来表示这个常数，所以：
    10 * log (x / N) - 10 * log (y /N)
    = 10 * log [(x / N) / ( y / N)]
    = 10 * log (x / y)

    来检查下这个公式有没有问题，用刚才的例子：
    10 * log ( .000792710162 / 0.000000000001) = 89 dB
    10 * log ( .000006288415 / 0.000000000001) = 68 dB
    89 dB - 68 dB = 21 dB
    对！这个方法可以让我们比较不同单位的数值。（这个例子的两个数据单位是相同的，所以看起来“参照数”没什么作用）
经常使用的测量单位有声音的功率（瓦特），声音的响度（瓦 / 米^），声音的压强是（帕斯卡）——下面请注意：以功率或响度为单位测量的数据，我们用上面的公式都可以很好的计算。然而，通常情况下，当人们说到“分贝”的时候，却指的是压强。毕竟是声波的压力压迫我们的耳鼓膜来让我们分辨出声音究竟有多“响”的。所以，我们通常所谈到的分贝应该是dBSPL（Sound PressureLevels）。压强是作用于单位面积的力，力的单位是牛顿，所以压强的单位是牛 / 米^。另一种常用的单位是帕斯卡，1 帕等于1 牛/米^。声响(I)和声压(P)之间的关系我们可以用下面的公式来表示：
    I = P^ / ρ
ρ是希腊字母，读作：“肉”，它代表空气的阻力，是一个常量。这个值取决于大气压强、空气温度等等因素。通常情况下，在室温中，空气阻力的值大约是400。因此，普通人能听见的最小的声音响度换算成声压就是：
0.000000000001W/m2 = (0.00002 Pa)^ / 400[/B]
    dB = 10 * log (x / y) --- 此时的X,Y是用声响作测量单位的，我们将P^ / ρ带入公式，则：
    dBspl = 10 * log [ (Px^ / ρ) /(Py^ / ρ) ]
        = 10 * log (Px^ / Py^)
        = 10 * log (Px / Py)^
        = 20 * log (Px / Py)
这就是dBSPL的公式，当我们谈论“分贝”的时候，99%说的都是它；我们在各种测量表上看见的dB，其实就是dBSPL，只不过没人说这个的时候总是带上SPL三个字母。那么当我们使用声压作为测量单位的时候，我们选用的“参照数”就是0.00002帕斯卡了，接近于我们所说的普通人能听见的最小的声音响度，带入刚才得到的公式，我们来看看：
    dBSPL = 20 * (P / 0.00002 Pa)
因为log1 = 0，所以：
    20 * log (0.00002 Pa / 0.00002 Pa) = 0 dB SPL
我们能忍受的最强的声压大约是20帕，你试试用分贝表示一下看看？应该如下：
    20 * log (20 Pa / .00002 Pa) = 120 dB
物理上超过120分贝的声音，我们就无法忍受了，这个值就是这么算的。总结一下：
    dBW = 10 * log (x / y) ---- 以声响作度量单位时计算分贝的公式，单位应该是 W / m^
    dBSPL = 20 * log (x / y) ---- 以声压作度量单位时计算分贝的公式，单位应该是 Pa
    声压对应声压级的关系，0.00002Pa=0dBSPL，0.0002Pa=20dBSPL，0.002Pa=40dBSPL， 0.02Pa=60dBSPL，0.2 Pa=80dBSPL，1 Pa=94dBSPL，2 Pa=100dBSPL，20Pa=120dBSPL
    分贝应当特别注意的是：分贝表示的是两个相同类型的数据之间的比（类型要相同，这一点很重要，你不能拿瓦特和伏特直接进行比较）。在这两个数据里，其中的一个我们把它叫做“参照数”，我们即是通过把测量到的数值和参照数代入公式进行计算来得到相应的分贝值的。比如之前我们已经使用过声压作为测量单位，那是我们选取的参照数是0.00002帕斯卡。我们最后得到的分贝值，我们称之为"dBSPL"。也就是说，dB后面不同的字母指示的就是我们用什么作为测量单位来得到这个分贝值的。用声压，那么就是SPL(Sound Pressure Levels)。

dBm:
    dB后面的m就代表毫瓦。dBm也是以功率为单位测量的，参照数是1mW。
    dBm = 10 * log (功率 / 1mW)
    -6dBm = 10 * log (.25mW / 1mW) = 10 * log (.25) = -6 dBm
dBu（也叫做dBv）:
    物理上，功率(P)还可以用电压(V)和电阻(R)之间的关系来表示：
    P = V^ / R
    刚才讨论dBm的时候，参照数是1mW。这个标准是在上个世纪三十年代设立的。在那个时候，所有音频设备的输入阻抗都是600欧姆，磁带录音机，调音台，前置功率放大器……只要有插头，那么从火线到接地之间的电阻就是600欧姆.那么，当电阻为600欧姆的时候，需要多大的电压才能产生1mW的功率呢？用刚才的公式计算一下：
    P = V^ / R
    0.001 W = V^ / 600 Ω
    V2 = 0.001 W * 600 Ω
    V = sqrt (0.001 W * 600 Ω) ---- sqrt是开平方
    V = 0.775 V
    答案是0.775伏特。那么，当所有的设备的输入阻抗还是600欧姆的那个年代，计算dBu时所用到的参照数就是0.775 V，也就是说，dBu就是以电压为测量单位是计算出的分贝值。不过我们又注意到，刚才的公式里电压是平方数。根据前面的经验，我们知道怎么处理这个问题：
    dBu = 20 * log (被测电压 / 0.775 V)
    +4dBu = 20 * log (被测电压 / 0.775 V)
    被测电压 = 1.228 V
    -10dBV = 20 * log (被测电压 / 1 V)
    被测电压 = 0.3162 V
    20 * log (1.228 V / 0.3162 V) = 11.79 dBu
    
dBFS:
    最后我们来看看和我们联系最密切的dBFS。dBFS的全称是"Decibels Full Scale"（全分贝刻度）——是一种为数字音频设备创立的分贝值表示方法。这个家伙它的参照数不是最小的一个，也不是中间的某一个，而是最大的一个！也就是说"0 dBFS"是数字设备能够到达的最高响度水平。此外所有的值都会小于这个数值——都是负数。这就是为什么我们在电脑上看到的峰值表的最高刻度都是"0"，并且指针永远不会读出更高的数字。
但是，为什么会这样呢？要解释这个问题，我们要简单说一下数字音频的存储原理。我们用16bit的数字音频为例："16bit"的意思是，采样信号以16位二进制数字来存储。二进制数字就两个："0"和"1"。所以，最大的值就是1111 1111 1111 1111（二进制，换算成十进制是65536），因此，计算dBFS的公式就是：
    dBFS = 20 * log (采样信号 / 1111 1111 1111 1111)
这样就很容易解释为什么不能超过"0"了，因为dBFS的参照数是最大值，所以：
    20 * log (1111 1111 1111 1111 / 1111 1111 1111 1111) = 0 dBFS
那么最小的呢？除了0之外，16位二进制最小的数字是：0000 0000 0000 0001，那么：
    20 * log (0000 0000 0000 0001 / 1111 1111 1111 1111) = -96 dBFS
    上面表术的是无符号16bit的类型，如果我们说有符号16bit的0dBFS是多少呢
    20 * log ((7FFF)0111 1111 1111 1111 / (7FFF)111 1111 1111 1111) = 0 dBFS
    20 * log ((8001)1000 0000 0000 0001 / (7FFF)111 1111 1111 1111) = -90 dBFS


中国规定
0dBFS=+24dBu
转换成600欧姆的电路需要的电压：
    24dBu = 20 × log (x/0.775 V)
    x = 12.282922242V

2016.1.8 
1. 关于AudioService中音量调整
  Android中的音量调整是分为Stream_type来的，stream_type主要包括stream_ring, stream_system, stream_music等。每个stream_type都有自己的音量系统，并且每个stream_type里面同时对每个设备的音量做了map，也就是每个stream_type里面的每个device的音量都是不相同的。
  第二个问题是关于steam_type_alias的问题，也就是stream别名，比如在手机上stream_system就对应到了stream_ring上，也就是stream_system与stream_ring共用一套音量系统，比如调整stream_ring音量的时候，同时会调整stream_system的音量，调整stream_system音量的时候，调整的是stream_ring的音量，因为调整stream_ring的时候，同时调整stream_system,所以会将两个音量同步。

2016.8.16
1. 理论
    人耳对小音量时比较敏感，比如增大1DB感觉很明显，但是随着声音的加大其听感随之变的不敏感，比如增大3DB也感觉不到很大的变化，其变化近似指数函数曲线的形式。
    Android音频曲线调用从ui界面往下设置，根据stream音频有不同的UI，分为7步，15步，对应到实际的100步。这个转换过程可以参考AudioPolicyManagerBase.cpp中的volIndexToAmpl函数。4.1上调用流程与之前的有所不同，原理还是一样的。之前的版本我看是直线型的，新的是3段折线的。为什么是直线，人耳对声音大小的感知程度并不是线性的，而是呈对数关系。这个可以和android原理对应起来
以10为底的对数。
    高频信号采样率使用的要高的问题， 比如使用44.1KHZ的采样率采样1HZ的信号时，可以采样出44.1K个点，但是我们采样频率为22KHZ的信号时候，只能采样2个点，因此在还原的时候，1HZ的还原的将会非常平滑，近乎原始声音，但是22KHZ只能还原2个点，所以音频可能会失真，所以，如果高频的声音需要使用更高的采样频率进行采样。
    1KHz,0dB的含义,不是一两句话可以说清楚,1KHz就比较容易理解了,就是说信号的频率是1KHz,0dB的含义就要涉及到音频信号的采样值的量化方面的知识了,对于CD音频,进行的是16位量化,每一个采样值都用16位二进制来表示,对于正弦信号,可以有很多种方式来表示,但不同的方式得出来的幅度大小不一样,当正弦信号的波峰对应的采样值量化的二进制值刚好用16二进制1来表示时,即波峰的采样值的量化值为1111 1111 1111 1111时,即用完了16位二进制来表示波峰的采样值了,这样的正弦信号就是0dB的正弦信号,至于它经过D/A转换成模拟信号的幅度是多少或者说CD机的读碟后输出的幅度是多少还要看CD机采用的D/A转换器的基准电压及放大电路的情况.如果正弦信号波峰的采样值的量化值小于111111111111,那么它就不是0dB信号了,而是负多少dB信号了.所以说0dB信号是CD机或DVD等数码音频播放器能输出的最大信号,当播放音乐时,通常是不能达到这个强度的.
    模拟系统或设备技术参数要求 主要技术参数要求给出待进行测定系统或设备的性能参数及指标值。它将随不同系统或设备有所不同。但均包括以下内容： 系统或设备输入及满足一定条件下的输入、输出特性,如某设备的此项参数要求写法为：输入电平-6dBu下，输出电平+4dBu(1kHz、负载600Ω、失真度≤0.5%) 
    输入特性 (1)输入电平: 设备满足一定条件(如规定的信号失真度、负载值等)时，额定输出(电压或功率)时输入端口所需要的信号电平，称之为输入电平。 电平与电压不同，前者指两个相同电量的比值取对数后用分贝(dB)表示；而电压是用电压度量单位kV、V、mV、μv标注。 在无线电技术中常引用分贝(dB)。分贝(dB)值是两个相同电学参数的比值再取以10为底的对数的20倍或10倍值。分为电压分贝值(LV)、电流分贝值(LI)、和功率分贝值(Lw)，其式见：
对于音频信号：
    一个语言或音乐信号在电路上的音量级用在600Ω电阻上供给１mW的1000Hz正弦电压的有效值作为基准，电压值等于0.775V(有效值)。基准量写为：0dBm (0dBm.600Ω/0.775V)或0dBu（0dBu=0.775V）。因此音频电压以0dBu＝0.775V为基准量，用×dBu表示音频电压电平值。对应于6dBu折算为电压有效值为: 6dB＝20lg (U/0.775) U＝ 2×0.775=1.55V 依照上面运算，又可得出-6dBu相应的电压有效值为0.3875V或387.5mV

2. 衰减系数推导过程
    amplifier： 缩放系数
    Attenuation_dBFS(要降低多少dBFS, 也就是要衰减多少dBFS) = 20 * log (amplifier)
    log10(X) = ln(x) / ln10   // 公式
    Attenuation_dBFS/20 = log(amplifier) = ln(amplifier) / ln10
    Attenuation_dBFS/20 * ln10 = ln(amplifier)
    amplifier = exp(Attenuation_dBFS/20 * ln10)

    last_dBFS = 20*log (amplifier * 采样信号/65535)
    last_dBFS/20 = log (amplifier) + log(采样信号 /65535)
    last_dBFS = 20*log (amplifier) + 20*log(采样信号 /65535)
    ori_dBFS = 20*log (采样信号/65535)
    Atu_dBFS = 20*log (amplifier)  //衰减的dBFS
    last_dBFS = Atu_dBFS + ori_dBFS (dBFS为负数，所以越加越小，音量减小)

3. 音频当中dBFS用加减表示调整音量大小。目前采用3段折线，我觉得可以更方便的调整声音在不同区域的变化大小。最低声音和最高声音应该需要从更底层驱动来调整。
volIndexToAmpl这个函数实现了上面的转换关系。该函数是通过响应音量键效益开始执行下面调用过程，完成音量大小调节的。
下面是音量键按下后的调用过程
Audiomanager.java
    handleKeyDown
    adjustSuggestStreamVolume
    service. adjustSuggestStreamVolume
AudioService.java
    adjustSuggestStreamVolume
    adjustStreamVolum
    sendMSG(mAudioHandler,MSG_SET_DEVICE_VOLUME,SND_QUEUE,device,0,streamstate,0);
消息机制
AudioService.java
    AudioHandler
    handleMessage
    setDeviceVolume
    StreamState.applyDeviceVolume
    audioSystem.setStreamVolumeIndex
JNI机制
    Android_media_AudioSystem.cpp
    AudioPolicyManagerBase.cpp
    setStreamVolumeIndex
    checkAndSetVolume
    computeVolume
    volIndexToAmpl

4. PCM有采样率，位深来表示，如16it位深， 则每个采样用16bit来表示，在计算机系统里面需要考虑采用什么数据方式。
定点：
    如， S16_LE， 小端有符号16位
    这都是PCM的一种表示范围的方法，所以表示方法中最小值等价，最大值等价，中间的数据级别就是对应的进度了，可以都映射到-1~1范围。 
    S8:     signed   8 bits，有符号字符 = char，          表示范围 -128~127 
    U8:     unsigned 8 bits，无符号字符 = unsigned char，表示范围 0~255 
    S16_LE: little endian signed 16 bits，小端有符号字 = short，表示范围 -32768~32767 
    S16_BE: big endian signed 16 bits，大端有符号字 = short倒序(PPC)，表示范围 -32768~32767 
    U16_LE: little endian unsigned 16 bits，小端无符号字 = unsigned short，表示范围 0~65535
    U16_BE: big endian unsigned signed 16 bits，大端无符号字 = unsigned short倒序(PPC)，表示范围 0~65535
还有S24_LE,S32_LE等，都可以表示数字的方法，PCM都可以用这些表示。
    浮点：
    上面这些值中，所有最小值-128, 0, -32768, -32768, 0, 0对应PCM描叙来说都是一个值，表示最小值，可以量化到浮点-1。所有最大值也是一个值，可以量化到浮点1，其他值可以等比例转换。
    PCMU应该是指无符号PCM：可以包括U8,U16_LE,U16_BE,...
    PCMA应该是指有符号PCM：可以包括S8,S16_LE,S16_BE,...

电压转换：
    VinMax = 5V, VinMin = -5V, DataMax = 32767, DataMin = -32768, 数据data对应的电压
    V = VinMin + data * (VinMax - VinMin)/ (DataMax - DataMin)
    (音频输入和PCM编码应该都是+/-双极性）


